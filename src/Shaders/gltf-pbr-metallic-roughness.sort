@Pass{
@DynamicState(dynamic-cull)
#extension GL_OES_standard_derivatives : enable
@BlendFunc(SRC_ALPHA,ONE_MINUS_SRC_ALPHA)
@ExposeMacro(int,jointCount,JOINT_COUNT,0)
FS_PREC(mediump,float)

varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUV;
#ifdef ATTRIBUTE_TANGENT_ENABLED
varying vec3 vTangent;
#endif
#ifdef VS
#if JOINT_COUNT > 0
  @JOINTMATRIX
  uniform mat4 boneMatrices[JOINT_COUNT];
#endif
  @NORMAL
  attribute vec3 normal;
  @POSITION
  attribute vec3 position;
#ifdef ATTRIBUTE_TEXCOORD_0_ENABLED
  @TEXCOORD_0
  attribute vec2 texCoord;
#endif
#ifdef ATTRIBUTE_TANGENT_ENABLED
  @TANGENT
  attribute vec3 tangent;
#endif
#if JOINT_COUNT > 0
  @JOINTS_0
  attribute vec4 joint;
  @WEIGHTS_0
  attribute vec4 weight;
#endif
  uniform mat4 _matPVM;
  uniform mat4 _matM;
  @MODELINVERSETRANSPOSE
  uniform mat4 normalMatrix;

  @CAMERA_POSITION
  uniform vec3 _cameraPositionVert;
  void main(){
    mat4 transform = _matM;
    mat4 projectionTransform = _matPVM;
    mat4 normalTransform = normalMatrix;
    #if JOINT_COUNT > 0
      mat4 skinMat = weight.x * boneMatrices[int(joint.x)] + weight.y * boneMatrices[int(joint.y)] + weight.z * boneMatrices[int(joint.z)] + weight.w * boneMatrices[int(joint.w)];
      transform *= skinMat;
      normalTransform *= skinMat;
      projectionTransform *= skinMat;
    #endif
    #ifdef ATTRIBUTE_TEXCOORD_0_ENABLED
        vUV = texCoord;
    #else
        vUV  = position.xy /2.0 + vec2(0.5);
    #endif
    vNormal = normalize(mat3(normalTransform) * normal);
    vPosition = (transform * vec4(position,1.0)).xyz;
    #ifdef ATTRIBUTE_TANGENT_ENABLED
    vTangent = normalize(mat3(normalTransform) * tangent);
    #endif
    gl_Position = projectionTransform * vec4(position,1.0);
  }


#endif


#ifdef FS
  @{flag:"USE_NORMAL_TEXTURE"}
  uniform sampler2D normalTexture;

  @{default:"white",type:"color"}
  uniform vec4 baseColorFactor;

  @{flag:"USE_BASECOLOR_TEXTURE"}
  uniform sampler2D baseColorTexture;

  @{default:"1"}
  uniform float metallicFactor;

  @{flag:"USE_METALLIC_TEXTURE"}
  uniform sampler2D metallicTexture;

  @{default:"1"}
  uniform float roughnessFactor;

  @{flag:"USE_ROUGHNESS_TEXTURE"}
  uniform sampler2D roughnessTexture;

  @{default:"black",type:"color"}
  uniform vec3 emissiveFactor;

  @{flag:"USE_EMISSIVE_TEXTURE"}
  uniform sampler2D emissiveTexture;

  @{flag:"USE_METALLIC_ROUGHNESS_TEXTURE"}
  uniform sampler2D metallicRoughnessTexture;

  @{flag:"USE_OCCLUSION_TEXTURE"}
  uniform sampler2D occlusionTexture;

  @CAMERA_POSITION
  uniform vec3 _cameraPosition;

  @import "forward-shading"

  void main(){
    vec4 baseColor = baseColorFactor;
    #ifdef USE_BASECOLOR_TEXTURE
      baseColor *= texture2D(baseColorTexture,vUV);
    #endif
    vec3 emissive = emissiveFactor;
    #ifdef USE_EMISSIVE_TEXTURE
      emissive *= texture2D(emissiveTexture,vUV).rgb;
    #endif
    float metallic = metallicFactor;
    #ifdef USE_METALLIC_TEXTURE
      metallic *= texture2D(metallicTexture,vUV).r;
    #endif
    float roughness = roughnessFactor;
    #ifdef USE_ROUGHNESS_TEXTURE
      roughness *= texture2D(roughnessTexture,vUV).r;
    #endif
    #ifdef USE_METALLIC_ROUGHNESS_TEXTURE
      vec3 rm = texture2D(metallicRoughnessTexture,vUV).rgb;
      metallic *= rm.b;
      roughness *= rm.g;
    #endif
    vec3 normal = normalize(vNormal);
    #ifdef USE_NORMAL_TEXTURE
      #ifndef ATTRIBUTE_TANGENT_ENABLED
      vec3 pos_dx = dFdx(vPosition);
      vec3 pos_dy = dFdy(vPosition);
      vec3 tex_dx = dFdx(vec3(vUV, 0.0));
      vec3 tex_dy = dFdy(vec3(vUV, 0.0));
      vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
      t = normalize(t - vNormal * dot(vNormal, t));
      #endif
      #ifdef ATTRIBUTE_TANGENT_ENABLED
      vec3 t = vTangent;
      #endif
      vec3 b = normalize(cross(vNormal, t));
      mat3 tbn = mat3(t, b, vNormal);
      vec3 n = texture2D(normalTexture, vUV).rgb;
      normal = normalize(tbn * (2.0 * n - 1.0));
    #endif
    normal *= (float(gl_FrontFacing) - 0.5) * 2.0;
    vec3 dielectricSpecular = vec3(0.04);
    vec3 diffuse = mix(baseColor.rgb * (1. - dielectricSpecular.r),vec3(0),metallic);
    vec3 f0 = mix(dielectricSpecular,baseColor.rgb,metallic);
    float alpha = roughness * roughness;
    pbr_params param = pbr_params(diffuse,f0,alpha,roughness);
    gl_FragColor.rgb = shading(param,normal,vPosition);
    gl_FragColor.rgb += emissive;
    #ifdef USE_OCCLUSION_TEXTURE
      gl_FragColor.rgb *= texture2D(occlusionTexture,vUV).r;
    #endif
    gl_FragColor.a = baseColor.a;
  }
#endif
}